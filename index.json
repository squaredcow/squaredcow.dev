[{"content":"An introduction to Conflict-Free Replicated Data Types Init Journey and Journal These past months I\u0026rsquo;ve been helping out with technical screen interviews on the job, the regular 1-hour meeting in which the candidate is given a code challenge and must provide a decent working solution by the end of it.\nSurprisingly enough, the place I work at does not provide access to any interview platform to assess the candidate\u0026rsquo;s skills, leaving me in a tight spot. From time to time, I have to request them to open the IDE of their choice and kindly share the screen, which I found invasive and likely to reduce the formality of the process.\nNowadays, there is a wide variety of paid services online such as CoderPad, CodeInterview, HackerRank, CoderByte; To mention a few, and all of them offer robust capabilities for online interviews.\nSimilarly, on the side of free software, we have etherpad, collabedit, and Plunker. These last ones have been an experience-saver when the candidate cannot share the screen for any reason, yet, these reflect intermittent issues lke edit-lag from time to time.\nThat situation got me intrigued and oddly inspired. How do all these real-time collaborative text platforms operate? What is the engineering behind it? Which type of technical challenge do they face, and which approaches do they follow?\nThose are plenty of questions, right? Here is where I start my amateur research on this particular topic: collaborative text in distributed systems.\nCollaborative Text: How does it work? Collaborative text web applications are asynchronous, fully powered by distributed systems, and challenged by their complexity. Consistency in the operations executed by the users takes the primary seat, while they are directly affected by the latency between the nodes.\nIf two users write, update or delete the same word in the document. Which change is the right one? Is it the last one? Is it the first one? How do we handle this edit conflict?\nIn an article published in 2011 by Marc Shapiro, Nuno Preguiça, Carlos Baquero, and Marek Zawirski named \u0026ldquo;A comprehensive study of Convergent and Commutative Replicated Data Types.\u0026rdquo;1 they propose the design of shared data types capable of conflict-free eventual consistency.\nQuoting the Abstract:\nEventual consistency aims to ensure that replicas of some mutable shared object converge without foreground synchronisation. Previous approaches to eventual consistency are ad-hoc and error-prone. We study a principled approach: to base the design of shared data types on some simple formal conditions that are sufficient to guarantee eventual consistency. We call these types Convergent or Commutative Replicated Data Types (CRDTs). (2011) 1\nThe infographic below displays an understandable glimpse of eventual consistency in optimistic replications. We will need at least this explanation as our bare minimum context to keep moving forward.\na). The AP of CAP\nDiving into CRDTs To properly define a CRDT we need to look into the smaller pieces used for their construction and later elaborate on the type of operations they can execute.\nThe clay and bricks of CRDTs CRDTs build and operate with mutable and immutable data types. The immutable types are named atoms, and they hold characteristics, such as:\nTheir content determines the type, e.g., primitives. They are copiable in between processes. If two of them have the same contents, they are equal. Meanwhile, the mutable types are named objects and have different characteristics than atoms, such as:\nThey hold identity and initial state. The contents of an object, also known as payload, are conformed by any number of atoms or objects. They expose an interface that defines contractual operations on the object. They are replicable in between processes. If two objects have the same identity but are present in different processes, they are considered replicas. The operations exposed for working with objects may follow two different approaches: state-based and operation-based.\nCategories of CRDTS In state-based (passive) replication, every state-changing operation occurs at the source then the system propagates the modified payload to an arbitrary pair of replicas infinitely often. The CRDTs implementing a state-based approach are named Convergent Replicated Data Type, CvRDTs.\nMeanwhile, in operation-based (active) replication, the system transmits the state-changing operations in two phases: at-source (local) and downstream (async. in replica) one after the other, and both of them must execute atomically. The CRDTs implementing an operation-based strategy are named Commutative Replicated Data Type, CmRDTs.\nNow, let\u0026rsquo;s have a quick grasp of one of the basic CvRDTs next.\nBuilding basic CRDTs Counters The most basic of the CRDTs, a primitive that lives within the replicas exposing a set of basic operations:\nIncrement/decrement the value of the counter. Update the value of the counter. Query the value of the counter. The value of the primitive must converge towards the global number of increments minus the number of decrements. These are some of the defined CRDTs counters 1:\nGrow-only Counter (G-Counter): state-based counter for positive increments only. Positive-Negative Counter (PN-Counter): state-based counter with a double registry for positive and negative increments. Non-negative Counter: similar to PN-Counter with the restriction of not beign able to generate more decrements than the current originated increments. To provide a more thorough view of one the counters mentioned above, we picked G-Counter to further explain its operations.\nGrow-only Counter (G-Counter) G-Counter is a state-based CRDT or CvRDT for positive increments only. As mentioned above it exposes a set of basic operations: init, increment, value, merge and compare. 2\nb). G-Counter OPS: init, increment and value.\nc). G-Counter OPS: merge and compare.\nTo further visualize a GCounter, we can easily create a class named GCounter that operates with integers and implements each of the methods explained above.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package com.squaredcow.crdts; import lombok.Data; import java.util.Arrays; @Data public final class GCounter implements Counter\u0026lt;Integer\u0026gt; { private Integer registryId; private Integer registrySize; private Integer[] innerRegistry; public GCounter(Integer registryId, Integer registrySize) { this.registryId = registryId; this.registrySize = registrySize; this.innerRegistry = new Integer[registrySize]; } @Override public GCounter init() { Arrays.fill(this.innerRegistry, 0); return this; } @Override public GCounter increment() { Integer id = this.registryId; this.innerRegistry[id] = this.innerRegistry[id] + 1; return this; } @Override public Integer value() { Integer result = 0; for(Integer counter : innerRegistry) { result += counter; } return result; } public Boolean compare(GCounter x, GCounter y) { for(Integer n : x.getInnerRegistry()) { if(x.getInnerRegistry()[n] \u0026lt;= y.getInnerRegistry()[n]) { return true; } } return false; } public Integer[] merge(GCounter x, GCounter y) { Integer[] mergedRegistry = new Integer[registrySize]; for(int i = 0; i \u0026lt; x.getInnerRegistry().length; i ++) { Integer vx = x.getInnerRegistry()[i]; Integer vy = y.getInnerRegistry()[i]; mergedRegistry[i] = Math.max(vx, vy); } return mergedRegistry; } } d). GCounter implementation in Java\nClosing words and next-steps This is an initial dive into the CRDTs structures themselves, we will eventually go deeper to construct a cluster of replicas that operate with them. We still need to go first through the rest of the structures mentioned, such as: registers, sets and graphs, but let\u0026rsquo;s have those on a second entry on this blog series.\nWith nothing left to add, thank you for reading all the way through, until next time.\n\u0026ndash; squaredcow\nhttps://hal.inria.fr/inria-00555588/document Shapiro, Marc; Preguiça, Nuno; Baquero, Carlos; Zawirski, Marek (13 January 2011). \u0026ldquo;A Comprehensive Study of Convergent and Commutative Replicated Data Types\u0026rdquo;. Rr-7506.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Conflict-free_replicated_data_type Section: Known CRDTs\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://squaredcow.dev/posts/axyghjet/","summary":"\u003ch4 id=\"an-introduction-to-conflict-free-replicated-data-types\"\u003eAn introduction to Conflict-Free Replicated Data Types\u003c/h4\u003e\n\u003ch2 id=\"init-journey-and-journal\"\u003eInit Journey and Journal\u003c/h2\u003e\n\u003cp\u003eThese past months I\u0026rsquo;ve been helping out with technical screen interviews on the job, the regular 1-hour meeting in which the candidate is given a code challenge and must provide a decent working solution by the end of it.\u003c/p\u003e\n\u003cp\u003eSurprisingly enough, the place I work at does not provide access to any interview platform to assess the candidate\u0026rsquo;s skills, leaving me in a tight spot.  From time to time, I have to request them to open the IDE of their choice and kindly share the screen, which I found invasive and likely to reduce the formality of the process.\u003c/p\u003e","title":"CRDTs for Collaborative Writing"},{"content":"Hey there: Welcome, I am Luis Vaca (squaredcow) owner and author of this blog.\nOnce I read on LinkedIn: \u0026ldquo;If you cannot explain in five words what do you do for a living, you are probably lying\u0026rdquo;. That said, I am a programmer and I enjoy it.\nNow, if I may give the verbose self-description: I am a programmer, graduated as Software Engineer, +10 years ago, focused on Web Services and Distributed Systems. I have been writing code for big-tech companies, start-ups, consultant firms and now, in this blog, for myself.\nSome of my topics of interest circle around programming languages, hashing, frameworks, optimizations, clever algorithms, generative art, et cetera. But I know, you the reader, will figure that out.\nLong due gratitude; This blog is meant for my peers, mentors, mentees, and all the new readers out there. May you find my findings as amusing as I did.\nAnd if you are interested in more, you can find the licensing for all the content of this page in here.\n\u0026ndash; squaredcow\n","permalink":"https://squaredcow.dev/author/","summary":"\u003ch2 id=\"hey-there\"\u003eHey there:\u003c/h2\u003e\n\u003cp\u003eWelcome, I am \u003cstrong\u003eLuis Vaca\u003c/strong\u003e (squaredcow) owner and author of this blog.\u003c/p\u003e\n\u003cp\u003eOnce I read on LinkedIn: \u003cem\u003e\u0026ldquo;If you cannot explain in five words what do you do for a living, you are probably lying\u0026rdquo;\u003c/em\u003e.\nThat said, I am a \u003cstrong\u003eprogrammer\u003c/strong\u003e and I enjoy it.\u003c/p\u003e\n\u003cp\u003eNow, if I may give the \u003cstrong\u003everbose\u003c/strong\u003e self-description: I am a programmer, graduated as\nSoftware Engineer, +10 years ago, focused on Web Services and Distributed Systems.\nI have been writing code for big-tech companies, start-ups, consultant firms\nand now, in this blog, for \u003cstrong\u003emyself\u003c/strong\u003e.\u003c/p\u003e","title":"About"},{"content":"Copyright © 2023 Luis Vaca All work done by the author is under dual-license. All the source code, is covered by the MIT License. All content and materials such as images, audios, records, etc. are covered by Creative Commons Attribution-ShareAlike 4.0 International License.\n","permalink":"https://squaredcow.dev/license/","summary":"\u003ch2 id=\"copyright--2023-luis-vaca\"\u003eCopyright © 2023 Luis Vaca\u003c/h2\u003e\n\u003cp\u003eAll work done by the author is under dual-license. All the source code, is covered by the MIT License. All content and materials such as images, audios, records, etc. are covered by Creative Commons Attribution-ShareAlike 4.0 International License.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://opensource.org/licenses/MIT\"\u003e\u003cimg alt=\"License: MIT\" loading=\"lazy\" src=\"https://img.shields.io/badge/License-MIT-green.svg\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://creativecommons.org/licenses/by-sa/4.0/\"\u003e\u003cimg alt=\"License: CC BY-SA 4.0\" loading=\"lazy\" src=\"https://img.shields.io/badge/License-CC%20BY--SA%204.0-blue.svg\"\u003e\u003c/a\u003e\u003c/p\u003e","title":""}]